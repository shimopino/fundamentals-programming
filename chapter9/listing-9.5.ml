(*
     #use "chapter9/listing-9.5.ml" ;;

     デザインレシピ

     データ構造
        入力データ、出力データの型を考える
        再帰的なデータ型である場合は、どこに再帰が含まれるのか確認する
        自己参照しないケースが存在することも確認する

     目的
        関数が何を達成するものなのかを考える
        入力・出力の型から関数シグネチャを考える

     例
        関数の動きを明確・具体的にするために、関数に望ましい振る舞いのデータを考える
        場合ごとの境界付近の値などを含むものを作成する
        再帰的な場合もデータを作成し、簡単に答えが出るケースと再帰が必要になるケースを考える

     テンプレート
        入力（の一部）が構造を持つデータや再帰構造を持つデータの場合には応じた match 構文を作成する
        再帰的な場合には、パターン変数を使用できるのか確認する
        場合分けに関しては条件を特定して必要な if 文を作成する

     本体
        関数の中身の実装を作成する

     テスト
        具体例を作成するときに一緒に作成したテストプログラムを実行する
*)

(*
     int list は
     - []              空リスト
     - first :: rest   最初の要素が first で残りのリストが rest (自己参照ケース)
*)

(* 目的：受け取ったリス lst の各要素の和を求める *)
(* sum : int list -> int *)
let sum lst = 0

(* 入力データの構造にあった形式の match 構文を作成する *)
let rec sum lst = match lst with [] -> 0 | first :: rest -> first + sum rest

(* テスト *)
let test1 = sum [] = 0
let test2 = sum [ 2 ] = 2
let test3 = sum [ 1; 3 ] = 4
